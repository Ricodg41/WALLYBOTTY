"""
Trading Strategy Module
=======================
Configurable trigger-based trading strategy engine.
"""

import logging
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum

from config import settings

logger = logging.getLogger(__name__)


class SignalType(Enum):
    """Types of trading signals."""
    BUY = 'buy'
    SELL = 'sell'
    HOLD = 'hold'


@dataclass
class TradingTriggers:
    """Configurable trading triggers."""
    
    # Buy triggers
    rsi_below: float = 30.0
    dip_percent: float = 5.0
    volume_spike: float = 1.5
    buy_enabled: bool = True
    buy_require_all: bool = False  # If True, all conditions must be met
    
    # Sell triggers
    rsi_above: float = 70.0
    rise_percent: float = 10.0
    stop_loss: float = 5.0
    take_profit: float = 15.0
    sell_enabled: bool = True
    
    def to_dict(self) -> Dict:
        """Convert to dictionary."""
        return {
            'buy': {
                'rsi_below': self.rsi_below,
                'dip_percent': self.dip_percent,
                'volume_spike': self.volume_spike,
                'enabled': self.buy_enabled,
                'require_all': self.buy_require_all,
            },
            'sell': {
                'rsi_above': self.rsi_above,
                'rise_percent': self.rise_percent,
                'stop_loss': self.stop_loss,
                'take_profit': self.take_profit,
                'enabled': self.sell_enabled,
            }
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'TradingTriggers':
        """Create from dictionary."""
        buy = data.get('buy', {})
        sell = data.get('sell', {})
        
        return cls(
            rsi_below=buy.get('rsi_below', 30.0),
            dip_percent=buy.get('dip_percent', 5.0),
            volume_spike=buy.get('volume_spike', 1.5),
            buy_enabled=buy.get('enabled', True),
            buy_require_all=buy.get('require_all', False),
            rsi_above=sell.get('rsi_above', 70.0),
            rise_percent=sell.get('rise_percent', 10.0),
            stop_loss=sell.get('stop_loss', 5.0),
            take_profit=sell.get('take_profit', 15.0),
            sell_enabled=sell.get('enabled', True),
        )


@dataclass
class TradingSignal:
    """A trading signal generated by the strategy."""
    signal_type: SignalType
    symbol: str
    price: float
    timestamp: datetime
    reasons: List[str]
    indicators: Dict
    confidence: float = 0.0  # 0-1 confidence score
    
    def to_dict(self) -> Dict:
        """Convert to dictionary for JSON serialization."""
        return {
            'signal_type': self.signal_type.value,
            'symbol': self.symbol,
            'price': self.price,
            'timestamp': self.timestamp.isoformat(),
            'reasons': self.reasons,
            'indicators': self.indicators,
            'confidence': self.confidence,
        }


@dataclass
class Position:
    """An open trading position."""
    symbol: str
    entry_price: float
    quantity: float
    entry_time: datetime
    side: str = 'long'  # 'long' or 'short'
    
    def to_dict(self) -> Dict:
        """Convert to dictionary."""
        return {
            'symbol': self.symbol,
            'entry_price': self.entry_price,
            'quantity': self.quantity,
            'entry_time': self.entry_time.isoformat(),
            'side': self.side,
        }


class TradingStrategy:
    """
    Configurable trading strategy engine.
    
    Evaluates market indicators against configurable triggers
    to generate buy/sell signals.
    """
    
    def __init__(self, triggers: TradingTriggers = None):
        self.triggers = triggers or TradingTriggers()
        self.positions: Dict[str, Position] = {}  # symbol -> Position
        
    def update_triggers(self, triggers_dict: Dict):
        """Update trading triggers from dictionary."""
        self.triggers = TradingTriggers.from_dict(triggers_dict)
        logger.info(f"Updated trading triggers: {self.triggers.to_dict()}")
    
    def evaluate(self, symbol: str, indicators: Dict) -> TradingSignal:
        """
        Evaluate indicators and generate a trading signal.
        
        Args:
            symbol: Trading pair (e.g., 'BTC/USDT')
            indicators: Dict with RSI, dip_percent, volume_spike, etc.
            
        Returns:
            TradingSignal with BUY, SELL, or HOLD recommendation
        """
        current_price = indicators.get('price', 0)
        
        # Check if we have an open position for this symbol
        position = self.positions.get(symbol)
        
        # Generate appropriate signal based on position status
        if position:
            return self._evaluate_sell(symbol, indicators, position)
        else:
            return self._evaluate_buy(symbol, indicators)
    
    def _evaluate_buy(self, symbol: str, indicators: Dict) -> TradingSignal:
        """Evaluate buy conditions."""
        if not self.triggers.buy_enabled:
            return self._hold_signal(symbol, indicators, ["Buy triggers disabled"])
        
        reasons = []
        conditions_met = []
        
        rsi = indicators.get('rsi', 50)
        dip = indicators.get('dip_percent', 0)
        vol_spike = indicators.get('volume_spike', 1.0)
        price = indicators.get('price', 0)
        
        # Check RSI condition
        if rsi < self.triggers.rsi_below:
            reasons.append(f"RSI ({rsi:.1f}) below {self.triggers.rsi_below}")
            conditions_met.append('rsi')
        
        # Check dip condition
        if dip >= self.triggers.dip_percent:
            reasons.append(f"Price dip ({dip:.1f}%) >= {self.triggers.dip_percent}%")
            conditions_met.append('dip')
        
        # Check volume spike condition
        if vol_spike >= self.triggers.volume_spike:
            reasons.append(f"Volume spike ({vol_spike:.1f}x) >= {self.triggers.volume_spike}x")
            conditions_met.append('volume')
        
        # Determine if we should buy
        should_buy = False
        if self.triggers.buy_require_all:
            # All conditions must be met
            should_buy = len(conditions_met) == 3
        else:
            # At least one condition must be met
            should_buy = len(conditions_met) >= 1
        
        if should_buy and reasons:
            confidence = len(conditions_met) / 3.0  # More conditions = higher confidence
            return TradingSignal(
                signal_type=SignalType.BUY,
                symbol=symbol,
                price=price,
                timestamp=datetime.now(),
                reasons=reasons,
                indicators=indicators,
                confidence=confidence,
            )
        
        return self._hold_signal(symbol, indicators, ["No buy conditions met"])
    
    def _evaluate_sell(self, symbol: str, indicators: Dict, position: Position) -> TradingSignal:
        """Evaluate sell conditions for an open position."""
        if not self.triggers.sell_enabled:
            return self._hold_signal(symbol, indicators, ["Sell triggers disabled"])
        
        reasons = []
        price = indicators.get('price', 0)
        rsi = indicators.get('rsi', 50)
        
        # Calculate profit/loss from entry
        pnl_percent = ((price - position.entry_price) / position.entry_price) * 100
        
        # Check RSI overbought condition
        if rsi > self.triggers.rsi_above:
            reasons.append(f"RSI ({rsi:.1f}) above {self.triggers.rsi_above}")
        
        # Check take profit
        if pnl_percent >= self.triggers.take_profit:
            reasons.append(f"Take profit reached ({pnl_percent:.1f}% >= {self.triggers.take_profit}%)")
        
        # Check stop loss
        if pnl_percent <= -self.triggers.stop_loss:
            reasons.append(f"Stop loss triggered ({pnl_percent:.1f}% <= -{self.triggers.stop_loss}%)")
        
        # Check rise percent from entry
        if pnl_percent >= self.triggers.rise_percent:
            reasons.append(f"Rise target reached ({pnl_percent:.1f}% >= {self.triggers.rise_percent}%)")
        
        if reasons:
            confidence = min(len(reasons) / 2.0, 1.0)
            return TradingSignal(
                signal_type=SignalType.SELL,
                symbol=symbol,
                price=price,
                timestamp=datetime.now(),
                reasons=reasons,
                indicators={**indicators, 'pnl_percent': pnl_percent, 'entry_price': position.entry_price},
                confidence=confidence,
            )
        
        return self._hold_signal(symbol, indicators, [f"Position open, P/L: {pnl_percent:.1f}%"])
    
    def _hold_signal(self, symbol: str, indicators: Dict, reasons: List[str]) -> TradingSignal:
        """Generate a HOLD signal."""
        return TradingSignal(
            signal_type=SignalType.HOLD,
            symbol=symbol,
            price=indicators.get('price', 0),
            timestamp=datetime.now(),
            reasons=reasons,
            indicators=indicators,
            confidence=0.0,
        )
    
    def add_position(self, symbol: str, entry_price: float, quantity: float) -> Position:
        """Record a new position."""
        position = Position(
            symbol=symbol,
            entry_price=entry_price,
            quantity=quantity,
            entry_time=datetime.now(),
        )
        self.positions[symbol] = position
        logger.info(f"Added position: {symbol} @ ${entry_price}")
        return position
    
    def close_position(self, symbol: str) -> Optional[Position]:
        """Remove a position when closed."""
        position = self.positions.pop(symbol, None)
        if position:
            logger.info(f"Closed position: {symbol}")
        return position
    
    def get_position(self, symbol: str) -> Optional[Position]:
        """Get an open position for a symbol."""
        return self.positions.get(symbol)
    
    def get_all_positions(self) -> Dict[str, Position]:
        """Get all open positions."""
        return self.positions.copy()
    
    def can_open_position(self, symbol: str) -> bool:
        """Check if we can open a new position."""
        # Check max positions
        if len(self.positions) >= settings.MAX_OPEN_POSITIONS:
            return False
        
        # Check if already have position in this symbol
        if symbol in self.positions:
            return False
        
        return True


# Singleton instance
_trading_strategy = None

def get_trading_strategy() -> TradingStrategy:
    """Get or create the trading strategy singleton."""
    global _trading_strategy
    if _trading_strategy is None:
        # Initialize with default triggers from settings
        triggers = TradingTriggers(
            rsi_below=settings.DEFAULT_BUY_TRIGGERS['rsi_below'],
            dip_percent=settings.DEFAULT_BUY_TRIGGERS['dip_percent'],
            volume_spike=settings.DEFAULT_BUY_TRIGGERS['volume_spike'],
            buy_enabled=settings.DEFAULT_BUY_TRIGGERS['enabled'],
            rsi_above=settings.DEFAULT_SELL_TRIGGERS['rsi_above'],
            rise_percent=settings.DEFAULT_SELL_TRIGGERS['rise_percent'],
            stop_loss=settings.DEFAULT_SELL_TRIGGERS['stop_loss'],
            take_profit=settings.DEFAULT_SELL_TRIGGERS['take_profit'],
            sell_enabled=settings.DEFAULT_SELL_TRIGGERS['enabled'],
        )
        _trading_strategy = TradingStrategy(triggers)
    return _trading_strategy
